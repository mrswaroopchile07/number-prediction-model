# -*- coding: utf-8 -*-
"""number-prediction-linear-regression

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1S96XIuwpaB7q4rZjrtf2ie4m6TUF4NZV

**Number Prediction Model**

Prediction of Numbers using Linera Regression.
Evalutation using MAE & MSE
Plot Graphical Data
Model tweaking with Epochs, Layers, Extra Input Layer etc.
"""

import tensorflow as tf
print(tf.__version__)

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

#features
X = np.array([-7.0, -4.0, -1.0, 2.0, 5.0, 8.0, 11.0, 14.0])
#labels
y = np.array([3.0, 6.0, 9.0, 12.0, 15.0, 18.0, 21.0, 24.0])
#visualize data
plt.scatter(X,y);

#create features and lables using tensors & visualise data

X = tf.constant([-7.0, -4.0, -1.0, 2.0, 5.0, 8.0, 11.0, 14.0])
y = tf.constant([3.0, 6.0, 9.0, 12.0, 15.0, 18.0, 21.0, 24.0])
plt.scatter(X,y);

#create a model

tf.random.set_seed(42)

model = tf.keras.Sequential([
    tf.keras.layers.Dense(1)
])
model.compile(loss=tf.keras.losses.mae,
              optimizer=tf.keras.optimizers.SGD(),
              metrics=["mae"])
model.fit(X,y,epochs=5)

model.predict([17.0])

#improving of model using Epochs Rate = 100

tf.random.set_seed(42)
model1 = tf.keras.Sequential([
                             tf.keras.layers.Dense(1)
])
model1.compile(loss = tf.keras.losses.mae,
               optimizer = tf.keras.optimizers.SGD(),
               metrics=["mae"])
model1.fit(X,y,epochs=100)

model1.predict([17.0])

#model improvement by large data set
X = np.arange(-100, 100,4)
y = np.arange(-90,110,4)

y = X + 10

#Spliting of Dataset using train_test_split
#first 40 samples
X_train = X[:40]
y_train = y[:40]

#last 10 samples
X_test = X[40:]
y_test = y[40:]
#len(X_train), len(X_test)

#Visualize the data
plt.scatter(X_train,y_train,c='b',label='Train Data')
plt.scatter(X_test, y_test, c='g',label='Test Data')
plt.legend();

#model with split data
tf.random.set_seed(42)
model2 = tf.keras.Sequential([
                              tf.keras.layers.Dense(1)
])

model2.compile(loss=tf.keras.losses.mae,
               optimizer=tf.keras.optimizers.SGD(),
               metrics=["mae"])

#model with input shape to layer

tf.random.set_seed(42)

model = tf.keras.Sequential([
                             tf.keras.layers.Dense(1,input_shape=[1])
])
model.compile(loss=tf.keras.losses.mae,
              optimizer=tf.keras.optimizers.SGD(),
              metrics=["mae"])
#model.summary()

model.fit(X_train,y_train,epochs=100,verbose=0)

#prediction
y_preds = model.predict(X_test)
y_preds

#plotting function to verify results
def plot_predictions(train_data=X_train,
                     train_labels=y_train,
                     test_data=X_test,
                     test_labels=y_test,
                     predictions=y_preds):
  plt.scatter(train_data,train_labels,c='b',label='Train data')
  plt.scatter(test_data, test_labels,c='g',label='Test Data')
  plt.scatter(test_data,predictions,c='r',label='Predicted Data')
  plt.legend();

#Call a function with passing our values
plot_predictions(X_train,
                 y_train,
                 X_test,
                 y_test,
                 y_preds)

#Evaluate the model - MAE / MSE
model.evaluate(X_test,y_test)

#Model Improvement - 

# 1. model_1 - same as original model, 1 layer, trained for 100 epochs.

tf.random.set_seed(42)
model_1 = tf.keras.Sequential([
                               tf.keras.layers.Dense(1)
])

model_1.compile(loss=tf.keras.losses.mae,
                optimizer=tf.keras.optimizers.SGD(),
                metrics=["mae"])
model_1.fit(X_train,y_train,epochs=100)

y_preds1 = model.predict(X_test)
plot_predictions(predictions=y_preds1)

# 2. add extra dense llayer

tf.random.set_seed(42)
model_2 = tf.keras.Sequential([
                               tf.keras.layers.Dense(1),
                               tf.keras.layers.Dense(1)
])

model_2.compile(loss=tf.keras.losses.mae,
                optimizer=tf.keras.optimizers.SGD(),
                metrics=["mae"])
model_2.fit(X_train,y_train,epochs=100,verbose=0)

y_preds2 = model_2.predict(X_test)
plot_predictions(predictions=y_preds2)

#model 3 with longer (500 epochs instead of 100).

tf.random.set_seed(42)
model_3 = tf.keras.Sequential([
                               tf.keras.layers.Dense(1)
])

model_3.compile(loss=tf.keras.losses.mae,
                optimizer=tf.keras.optimizers.SGD(),
                metrics=["mae"])
model_3.fit(X_train,y_train,epochs=500,verbose=0)

y_preds3 = model_3.predict(X_test)
plot_predictions(predictions=y_preds3)

#Evaluate the model using MAE and MSE
def mae(y_test, y_pred):
  return tf.metrics.mean_absolute_error(y_test,y_pred)

def mse(y_test, y_pred):
  return tf.metrics.mean_squared_error(y_test, y_pred)

#Evaluation of Model1
mae_1 = mae(y_test,y_preds1.squeeze()).numpy()
mse_1 = mse(y_test,y_preds1.squeeze()).numpy()
mae_1,mse_1

#Evaluation of Model2
mae_2 = mae(y_test,y_preds2.squeeze()).numpy()
mse_2 = mse(y_test,y_preds2.squeeze()).numpy()
mae_2,mse_2

#Evaluation of Model3
mae_3 = mae(y_test,y_preds3.squeeze()).numpy()
mse_3 = mse(y_test,y_preds3.squeeze()).numpy()
mae_3,mse_3

#Model Results
model_results = [["model_1",mae_1,mse_1],
                 ["model_2",mae_2,mse_2],
                 ["model_3",mae_3,mse_3]]

all_results = pd.DataFrame(model_results, columns=["MODELS","MAE","MSE"])
all_results

#Save the best model

model_2.save('best_model_SavedModel_format')

#Loading the best saved model
loaded_saved_model = tf.keras.models.load_model("best_model_SavedModel_format")
loaded_saved_model.summary()